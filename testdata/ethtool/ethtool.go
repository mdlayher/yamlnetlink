// Package main is generated from a YAML netlink specification for family "ethtool".
//
// Description: Ethernet device configuration interface.
//
// Code generated by yamlnetlink-go. DO NOT EDIT.
package main

import (
	"errors"

	"github.com/mdlayher/genetlink"
	"github.com/mdlayher/netlink"
	"golang.org/x/sys/unix"
)

// A Conn is a connection to netlink family "ethtool".
type Conn struct {
	c *genetlink.Conn
	f genetlink.Family
}

// Dial opens a Conn for netlink family "ethtool". Any options are passed directly
// to the underlying netlink package.
func Dial(cfg *netlink.Config) (*Conn, error) {
	c, err := genetlink.Dial(cfg)
	if err != nil {
		return nil, err
	}

	f, err := c.GetFamily("ethtool")
	if err != nil {
		return nil, err
	}

	return &Conn{c: c, f: f}, nil
}

// Close closes the Conn's underlying netlink connection.
func (c *Conn) Close() error { return c.c.Close() }

// DoChannelsGet wraps the "channels-get" operation:
// Get current and max supported number of channels.
func (c *Conn) DoChannelsGet(req DoChannelsGetRequest) (*DoChannelsGetReply, error) {
	ae := netlink.NewAttributeEncoder()
	// TODO: field "req.Header", type "nest"

	b, err := ae.Encode()
	if err != nil {
		return nil, err
	}

	msg := genetlink.Message{
		Header: genetlink.Header{
			Command: unix.ETHTOOL_MSG_CHANNELS_GET,
			Version: c.f.Version,
		},
		Data: b,
	}

	msgs, err := c.c.Execute(msg, c.f.ID, netlink.Request)
	if err != nil {
		return nil, err
	}

	replies := make([]*DoChannelsGetReply, 0, len(msgs))
	for _, m := range msgs {
		ad, err := netlink.NewAttributeDecoder(m.Data)
		if err != nil {
			return nil, err
		}

		var reply DoChannelsGetReply
		for ad.Next() {
			switch ad.Type() {
			case unix.ETHTOOL_A_CHANNELS_HEADER:
				// TODO: field "reply.Header", type "nest"
			case unix.ETHTOOL_A_CHANNELS_RX_MAX:
				reply.RxMax = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_TX_MAX:
				reply.TxMax = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_OTHER_MAX:
				reply.OtherMax = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_COMBINED_MAX:
				reply.CombinedMax = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_RX_COUNT:
				reply.RxCount = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_TX_COUNT:
				reply.TxCount = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_OTHER_COUNT:
				reply.OtherCount = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_COMBINED_COUNT:
				reply.CombinedCount = ad.Uint32()
			}
		}

		if err := ad.Err(); err != nil {
			return nil, err
		}

		replies = append(replies, &reply)
	}

	if len(replies) != 1 {
		return nil, errors.New("ethtool: expected exactly one DoChannelsGetReply")
	}

	return replies[0], nil
}

// DumpChannelsGet wraps the "channels-get" operation:
// Get current and max supported number of channels.
func (c *Conn) DumpChannelsGet() ([]*DumpChannelsGetReply, error) {
	// No attribute arguments.
	var b []byte

	msg := genetlink.Message{
		Header: genetlink.Header{
			Command: unix.ETHTOOL_MSG_CHANNELS_GET,
			Version: c.f.Version,
		},
		Data: b,
	}

	msgs, err := c.c.Execute(msg, c.f.ID, netlink.Request|netlink.Dump)
	if err != nil {
		return nil, err
	}

	replies := make([]*DumpChannelsGetReply, 0, len(msgs))
	for _, m := range msgs {
		ad, err := netlink.NewAttributeDecoder(m.Data)
		if err != nil {
			return nil, err
		}

		var reply DumpChannelsGetReply
		for ad.Next() {
			switch ad.Type() {
			case unix.ETHTOOL_A_CHANNELS_HEADER:
				// TODO: field "reply.Header", type "nest"
			case unix.ETHTOOL_A_CHANNELS_RX_MAX:
				reply.RxMax = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_TX_MAX:
				reply.TxMax = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_OTHER_MAX:
				reply.OtherMax = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_COMBINED_MAX:
				reply.CombinedMax = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_RX_COUNT:
				reply.RxCount = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_TX_COUNT:
				reply.TxCount = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_OTHER_COUNT:
				reply.OtherCount = ad.Uint32()
			case unix.ETHTOOL_A_CHANNELS_COMBINED_COUNT:
				reply.CombinedCount = ad.Uint32()
			}
		}

		if err := ad.Err(); err != nil {
			return nil, err
		}

		replies = append(replies, &reply)
	}

	return replies, nil
}

// DoChannelsGetRequest is used with the DoChannelsGet method.
type DoChannelsGetRequest struct {
	// TODO: field "Header", type "nest"
}

// DoChannelsGetReply is used with the DoChannelsGet method.
type DoChannelsGetReply struct {
	// TODO: field "Header", type "nest"
	RxMax         uint32
	TxMax         uint32
	OtherMax      uint32
	CombinedMax   uint32
	RxCount       uint32
	TxCount       uint32
	OtherCount    uint32
	CombinedCount uint32
}

// DumpChannelsGetReply is used with the DumpChannelsGet method.
type DumpChannelsGetReply struct {
	// TODO: field "Header", type "nest"
	RxMax         uint32
	TxMax         uint32
	OtherMax      uint32
	CombinedMax   uint32
	RxCount       uint32
	TxCount       uint32
	OtherCount    uint32
	CombinedCount uint32
}

// DoChannelsSet wraps the "channels-set" operation:
// Set number of channels.
func (c *Conn) DoChannelsSet(req DoChannelsSetRequest) error {
	ae := netlink.NewAttributeEncoder()
	// TODO: field "req.Header", type "nest"
	if req.RxCount != 0 {
		ae.Uint32(unix.ETHTOOL_A_CHANNELS_RX_COUNT, req.RxCount)
	}
	if req.TxCount != 0 {
		ae.Uint32(unix.ETHTOOL_A_CHANNELS_TX_COUNT, req.TxCount)
	}
	if req.OtherCount != 0 {
		ae.Uint32(unix.ETHTOOL_A_CHANNELS_OTHER_COUNT, req.OtherCount)
	}
	if req.CombinedCount != 0 {
		ae.Uint32(unix.ETHTOOL_A_CHANNELS_COMBINED_COUNT, req.CombinedCount)
	}

	b, err := ae.Encode()
	if err != nil {
		return err
	}

	msg := genetlink.Message{
		Header: genetlink.Header{
			Command: unix.ETHTOOL_MSG_CHANNELS_SET,
			Version: c.f.Version,
		},
		Data: b,
	}

	// No replies.
	_, err = c.c.Execute(msg, c.f.ID, netlink.Request)
	return err
}

// DoChannelsSetRequest is used with the DoChannelsSet method.
type DoChannelsSetRequest struct {
	// TODO: field "Header", type "nest"
	RxCount       uint32
	TxCount       uint32
	OtherCount    uint32
	CombinedCount uint32
}
